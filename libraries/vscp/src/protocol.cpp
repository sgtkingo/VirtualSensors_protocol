/**
 * @file protocol.cpp
 * @brief Implementation of the Protocol class for handling API communication protocol.
 * 
 * This file implements the Protocol class static methods for managing sensor communication
 * using a URL-like protocol format. It handles initialization, data updates, configuration,
 * reset, connect, and disconnect operations for sensors.
 * 
 * @copyright 2024 MTA
 * @author Generated by GitHub Copilot
 */

#include "protocol.hpp"

#include <sstream>
#include <algorithm> // For std::transform

// Static member definitions
const std::string Protocol::API_VERSION = "1.2";
bool Protocol::initialized = false;

std::unordered_map<std::string, std::string> Protocol::parseMessage(const std::string& message, bool caseSensitive = CASE_SENSITIVE) {
    std::unordered_map<std::string, std::string> params;
    
    // Remove leading '?' if present
    std::string cleanMessage = message;
    if(!caseSensitive)
    {
        // Convert to lowercase
        std::transform(cleanMessage.begin(), cleanMessage.end(), cleanMessage.begin(), ::tolower);
    }

    if (!cleanMessage.empty() && cleanMessage[0] == '?') {
        cleanMessage = cleanMessage.substr(1);
    }
    
    // Split by '&' to get key-value pairs
    std::stringstream ss(cleanMessage);
    std::string pair;
    
    while (std::getline(ss, pair, '&')) {
        size_t equalPos = pair.find('=');
        if (equalPos != std::string::npos) {
            std::string key = pair.substr(0, equalPos);
            std::string value = pair.substr(equalPos + 1);
            params[key] = value;
        }
    }
    
    return params;
}

std::string Protocol::buildMessage(const std::unordered_map<std::string, std::string>& params) {
    std::stringstream ss;
    ss << "?";
    
    bool first = true;
    for (const auto& pair : params) {
        if (!first) {
            ss << "&";
        }
        ss << pair.first << "=" << pair.second;
        first = false;
    }
    
    return ss.str();
}

bool Protocol::init_dummy(int verbose) {
    try {
        // First init messenger
        initMessenger();

        // Build initialization request
        std::unordered_map<std::string, std::string> params;
        params["type"] = "INIT";

        std::string request = buildMessage(params);
        
        // Send request and receive response
        sendMessage(request); 

        // Thats all
        initialized = true;
        return initialized;
    } catch (const Exception& e) {
        if (verbose) {
            throw; // Re-throw the exception in verbose mode
        }
        return false; // Return false in silent mode
    }
    catch (std::exception& e) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::init_dummy", e.what());
        }
        return false; // Return false in silent mode
    }
    catch (...) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::init_dummy", "Unknown error occurred during init_dummy");
        }
        return false; // Return false in silent mode
    }
}

bool Protocol::init(int verbose)  {
    try {
        // First init messenger
        initMessenger();
        
        // Build initialization request
        std::unordered_map<std::string, std::string> params;
        params["type"] = "INIT";
        params["api"] = API_VERSION;
        
        std::string request = buildMessage(params);
        
        // Send request and receive response
        sendMessage(request); 
        std::string response = receiveMessage(500); // 500 ms timeout for init
        
        // Parse response
        auto responseParams = parseMessage(response);
        
        // Check if initialization was successful
        if (responseParams.find("status") != responseParams.end()) {
            initialized = (responseParams["status"] == "1");
            return initialized;
        }
        
        return false;
    } catch (const Exception& e) {
        if (verbose) {
            throw; // Re-throw the exception in verbose mode
        }
        return false; // Return false in silent mode
    }
    catch (std::exception& e) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::init", e.what());
        }
        return false; // Return false in silent mode
    }
    catch (...) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::init", "Unknown error occurred during init");
        }
        return false; // Return false in silent mode
    }
}

bool Protocol::init(const std::string& db_version, int verbose)  {
    try {
        // First init messenger
        initMessenger();
        
        // Build initialization request
        std::unordered_map<std::string, std::string> params;
        params["type"] = "INIT";
        params["db"] = db_version;
        params["api"] = API_VERSION;
        
        std::string request = buildMessage(params);
        
        // Send request and receive response
        sendMessage(request); 
        std::string response = receiveMessage(500); // 500 ms timeout for init
        
        // Parse response
        auto responseParams = parseMessage(response);
        
        // Check if initialization was successful
        if (responseParams.find("status") != responseParams.end()) {
            initialized = (responseParams["status"] == "1");
            return initialized;
        }
        
        return false;
    } catch (const Exception& e) {
        if (verbose) {
            throw; // Re-throw the exception in verbose mode
        }
        return false; // Return false in silent mode
    }
    catch (std::exception& e) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::init", e.what());
        }
        return false; // Return false in silent mode
    }
    catch (...) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::init", "Unknown error occurred during init");
        }
        return false; // Return false in silent mode
    }
}


bool Protocol::init(const std::string& app_name, const std::string& db_version, int verbose) {
    try {
        // First init messenger
        initMessenger();
        
        // Build initialization request
        std::unordered_map<std::string, std::string> params;
        params["type"] = "INIT";
        params["app"] = app_name;
        params["db"] = db_version;
        params["api"] = API_VERSION;
        
        std::string request = buildMessage(params);
        
        // Send request and receive response
        sendMessage(request); 
        std::string response = receiveMessage(500); // 500 ms timeout for init
        
        // Parse response
        auto responseParams = parseMessage(response);
        
        // Check if initialization was successful
        if (responseParams.find("status") != responseParams.end()) {
            initialized = (responseParams["status"] == "1");
            return initialized;
        }
        
        return false;
    } catch (const Exception& e) {
        if (verbose) {
            throw; // Re-throw the exception in verbose mode
        }
        return false; // Return false in silent mode
    }
    catch (std::exception& e) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::init", e.what());
        }
        return false; // Return false in silent mode
    }
    catch (...) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::init", "Unknown error occurred during init");
        }
        return false; // Return false in silent mode
    }
}

std::unordered_map<std::string, std::string> Protocol::update(const std::string& uid, int verbose) {
    if (!initialized) {
        if (verbose) {
            throw ProtocolNotInitializedException("Protocol::update", "Protocol not initialized before calling update method");
        }
        return std::unordered_map<std::string, std::string>(); // Return empty map in silent mode
    }
    
    if (uid.empty()) {
        if (verbose) {
            throw ValueNotFoundException("Protocol::update", "Sensor UID cannot be empty");
        }
        return std::unordered_map<std::string, std::string>(); // Return empty map in silent mode
    }
    
    try {
        // Build update request
        std::unordered_map<std::string, std::string> params;
        params["type"] = "UPDATE";
        params["id"] = uid;
        
        std::string request = buildMessage(params);
        
        // Send request and receive response
        sendMessage(request);
        std::string response = receiveMessage();
        
        // Parse response
        auto responseParams = parseMessage(response);
        
        // Check if UID from response matches request
        if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
            if (verbose) {
                throw ProtocolMethodFailException("Protocol::update", "Response UID mismatch - expected: " + uid + ", received: " + 
                              (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none"));
            }
            return std::unordered_map<std::string, std::string>(); // Return empty map in silent mode
        }
        
        // Check if update was successful
        if (responseParams.find("status") != responseParams.end() && 
            responseParams["status"] == "1") {
            return responseParams;
        } else {
            if (verbose) {
                std::string error = responseParams.find("error") != responseParams.end() 
                                  ? responseParams["error"] : "Update failed";
                throw ProtocolMethodFailException("Protocol::update", "Update failed: " + error);
            }
            return std::unordered_map<std::string, std::string>(); // Return empty map in silent mode
        }
    } catch (const Exception& e) {
        if (verbose) {
            throw e; // Re-throw the exception in verbose mode
        }
        return std::unordered_map<std::string, std::string>(); // Return empty map in silent mode
    }
    catch (std::exception& e) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::update", e.what());
        }
        return std::unordered_map<std::string, std::string>(); // Return empty map in silent mode
    }
    catch (...) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::update", "Unknown error occurred during update");
        }
        return std::unordered_map<std::string, std::string>(); // Return empty map in silent mode
    }
}

bool Protocol::config(const std::string& uid, const std::unordered_map<std::string, std::string>& config, int verbose) {
    if (!initialized) {
        if (verbose) {
            throw ProtocolNotInitializedException("Protocol::config", "Protocol not initialized before calling config method");
        }
        return false; // Return false in silent mode
    }
    
    if (uid.empty()) {
        if (verbose) {
            throw ValueNotFoundException("Protocol::config", "Sensor UID cannot be empty");
        }
        return false; // Return false in silent mode
    }
    
    try {
        // Build configuration request
        std::unordered_map<std::string, std::string> params;
        params["type"] = "CONFIG";
        params["id"] = uid;
        
        // Add configuration parameters
        for (const auto& configParam : config) {
            params[configParam.first] = configParam.second;
        }
        
        std::string request = buildMessage(params);
        
        // Send request and receive response
        sendMessage(request);
        std::string response = receiveMessage();
        
        // Parse response
        auto responseParams = parseMessage(response);
        
        // Check if UID from response matches request
        if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
            if (verbose) {
                throw ProtocolMethodFailException("Protocol::config", "Response UID mismatch - expected: " + uid + ", received: " + 
                              (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none"));
            }
            return false; // Return false in silent mode
        }
        
        // Check if configuration was successful
        return (responseParams.find("status") != responseParams.end() && 
                responseParams["status"] == "1");
    } catch (const Exception& e) {
        if (verbose) {
            throw e; // Re-throw the exception in verbose mode
        }
        return false; // Return false in silent mode
    }
    catch (std::exception& e) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::config", e.what());
        }
        return false; // Return false in silent mode
    }
    catch (...) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::config", "Unknown error occurred during config");
        }
        return false; // Return false in silent mode
    }
}

bool Protocol::reset(const std::string& uid, int verbose) {
    if (!initialized) {
        if (verbose) {
            throw ProtocolNotInitializedException("Protocol::reset", "Protocol not initialized before calling reset method");
        }
        return false; // Return false in silent mode
    }
    
    if (uid.empty()) {
        if (verbose) {
            throw ValueNotFoundException("Protocol::reset", "Sensor UID cannot be empty");
        }
        return false; // Return false in silent mode
    }
    
    try {
        // Build reset request
        std::unordered_map<std::string, std::string> params;
        params["type"] = "RESET";
        params["id"] = uid;
        
        std::string request = buildMessage(params);
        
        // Send request and receive response
        sendMessage(request);
        std::string response = receiveMessage();
        
        // Parse response
        auto responseParams = parseMessage(response);
        
        // Check if UID from response matches request
        if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
            if (verbose) {
                throw ProtocolMethodFailException("Protocol::reset", "Response UID mismatch - expected: " + uid + ", received: " + 
                              (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none"));
            }
            return false; // Return false in silent mode
        }
        
        // Check if reset was successful
        return (responseParams.find("status") != responseParams.end() && 
                responseParams["status"] == "1");
    } catch (const Exception& e) {
        if (verbose) {
            throw e; // Re-throw the exception in verbose mode
        }
        return false; // Return false in silent mode
    }
    catch (std::exception& e) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::reset", e.what());
        }
        return false; // Return false in silent mode
    }
    catch (...) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::reset", "Unknown error occurred during reset");
        }
        return false; // Return false in silent mode
    }
}

bool Protocol::connect(const std::string& uid, const std::string& pins, int verbose) {
    if (!initialized) {
        if (verbose) {
            throw ProtocolNotInitializedException("Protocol::connect", "Protocol not initialized before calling connect method");
        }
        return false; // Return false in silent mode
    }
    
    if (uid.empty()) {
        if (verbose) {
            throw ValueNotFoundException("Protocol::connect", "Sensor UID cannot be empty");
        }
        return false; // Return false in silent mode
    }
    
    try {
        // Build connect request
        std::unordered_map<std::string, std::string> params;
        params["type"] = "CONNECT";
        params["id"] = uid;
        params["pins"] = pins;
        
        std::string request = buildMessage(params);
        
        // Send request and receive response
        sendMessage(request);
        std::string response = receiveMessage();
        
        // Parse response
        auto responseParams = parseMessage(response);
        
        // Check if UID from response matches request
        if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
            if (verbose) {
                throw ProtocolMethodFailException("Protocol::connect", "Response UID mismatch - expected: " + uid + ", received: " + 
                              (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none"));
            }
            return false; // Return false in silent mode
        }
        
        // Check if connection was successful
        return (responseParams.find("status") != responseParams.end() && 
                responseParams["status"] == "1");
    } catch (const Exception& e) {
        if (verbose) {
            throw e; // Re-throw the exception in verbose mode
        }
        return false; // Return false in silent mode
    }
    catch (std::exception& e) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::connect", e.what());
        }
        return false; // Return false in silent mode
    }
    catch (...) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::connect", "Unknown error occurred during connect");
        }
        return false; // Return false in silent mode
    }
}

bool Protocol::disconnect(const std::string& uid, int verbose) {
    if (!initialized) {
        if (verbose) {
            throw ProtocolNotInitializedException("Protocol::disconnect", "Protocol not initialized before calling disconnect method");
        }
        return false; // Return false in silent mode
    }
    
    if (uid.empty()) {
        if (verbose) {
            throw ValueNotFoundException("Protocol::disconnect", "Sensor UID cannot be empty");
        }
        return false; // Return false in silent mode
    }
    
    try {
        // Build disconnect request
        std::unordered_map<std::string, std::string> params;
        params["type"] = "DISCONNECT";
        params["id"] = uid;
        
        std::string request = buildMessage(params);
        
        // Send request and receive response
        sendMessage(request);
        std::string response = receiveMessage();
        
        // Parse response
        auto responseParams = parseMessage(response);
        
        // Check if UID from response matches request
        if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
            if (verbose) {
                throw ProtocolMethodFailException("Protocol::disconnect", "Response UID mismatch - expected: " + uid + ", received: " + 
                              (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none"));
            }
            return false; // Return false in silent mode
        }
        
        // Check if disconnection was successful
        return (responseParams.find("status") != responseParams.end() && 
                responseParams["status"] == "1");
    } catch (const Exception& e) {
        if (verbose) {
            throw e; // Re-throw the exception in verbose mode
        }
        return false; // Return false in silent mode
    }
    catch (std::exception& e) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::disconnect", e.what());
        }
        return false; // Return false in silent mode
    }
    catch (...) {
        if (verbose) {
            throw ProtocolMethodFailException("Protocol::disconnect", "Unknown error occurred during disconnect");
        }
        return false; // Return false in silent mode
    }
}

bool Protocol::isInitialized() {
    return initialized;
}

std::string Protocol::getApiVersion() {
    return API_VERSION;
}