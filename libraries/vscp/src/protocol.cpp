/**
 * @file protocol.cpp
 * @brief Implementation of the Protocol class for handling API communication protocol.
 * 
 * This file implements the Protocol class static methods for managing sensor communication
 * using a URL-like protocol format. It handles initialization, data updates, configuration,
 * reset, connect, and disconnect operations for sensors.
 * 
 * @copyright 2024 MTA
 * @author Generated by GitHub Copilot
 */

#include "protocol.hpp"
//#include <expt.hpp> // For std::exception and logs

#include <sstream> // For std::stringstream
#include <algorithm> // For std::transform
#include <cctype> // For std::isspace

// Static member definitions
const std::string Protocol::API_VERSION = "1.2";
bool Protocol::initialized = false;

// Helper function to trim whitespace and invisible characters from strings
static std::string trim(const std::string& str) {
    // Find first non-whitespace character
    size_t start = 0;
    while (start < str.length() && (std::isspace(static_cast<unsigned char>(str[start])) || str[start] < 32)) {
        start++;
    }
    
    // If string is all whitespace
    if (start == str.length()) {
        return "";
    }
    
    // Find last non-whitespace character
    size_t end = str.length() - 1;
    while (end > start && (std::isspace(static_cast<unsigned char>(str[end])) || str[end] < 32)) {
        end--;
    }
    
    return str.substr(start, end - start + 1);
}

std::unordered_map<std::string, std::string> Protocol::parseMessage(const std::string& message, bool caseSensitive) {
    static std::unordered_map<std::string, std::string> params;
    params.clear();
    
    // Remove leading '?' if present
    std::string cleanMessage = message;
    if(!caseSensitive)
    {
        // Convert to lowercase
        std::transform(cleanMessage.begin(), cleanMessage.end(), cleanMessage.begin(), ::tolower);
    }

    if (!cleanMessage.empty() && cleanMessage[0] == '?') {
        cleanMessage = cleanMessage.substr(1);
    }
    
    // Split by '&' to get key-value pairs
    std::stringstream ss(cleanMessage);
    std::string pair;
    
    while (std::getline(ss, pair, '&')) {
        size_t equalPos = pair.find('=');
        if (equalPos != std::string::npos) {
            std::string key = trim(pair.substr(0, equalPos));
            std::string value = trim(pair.substr(equalPos + 1));
            
            // Only add non-empty keys
            if (!key.empty()) {
                params[key] = value;
            }
        }
    }
    
    return params;
}

ResponseStatus Protocol::init_dummy() {
    ResponseStatus response;
    
    // First init messenger
    initMessenger();

    // Build initialization request
    std::string request = "?type=INIT";
 
    // Send request and receive response
    sendMessage(request); 

    //dummy response for test mode - always successful
    response.status = ResponseStatusEnum::OK;
    response.error = "";
    
    // Thats all
    initialized = true;
    return response;
}

ResponseStatus Protocol::init() {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;
    
    // First init messenger
    initMessenger();
    
    // Build initialization request
    std::string request = "?type=INIT";
    request += "&api=" + API_VERSION;

    // Send request and receive response
    sendMessage(request); 
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE, PROTOCOL_INIT_TIMEOUT); 
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if initialization was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {
        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Initialization failed - bad or missing status";

        return response;
    } 

    response.status = ResponseStatusEnum::OK;
    response.error = "";
    initialized = true; 
    return response;
}

ResponseStatus Protocol::init(const std::string& db_version) {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;
    
    // First init messenger
    initMessenger();
    
    // Build initialization request
    std::string request = "?type=INIT";
    request += "&db=" + db_version;
    request += "&api=" + API_VERSION;
    
    // Send request and receive response
    sendMessage(request); 
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE, PROTOCOL_INIT_TIMEOUT); 
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if initialization was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {
        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Initialization failed - bad or missing status";

        return response;
    } 

    response.status = ResponseStatusEnum::OK;
    response.error = "";
    initialized = true; 
    return response;
}

ResponseStatus Protocol::init(const std::string& app_name, const std::string& db_version) {
    if (app_name.empty() && db_version.empty()) {
        return init();
    } else if (db_version.empty()) {
        return init();
    } else if (app_name.empty()) {
        return init(db_version);
    }

    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;
    
    // First init messenger
    initMessenger();
    
    // Build initialization request
    std::string request = "?type=INIT";
    request += "&app=" + app_name;
    request += "&db=" + db_version;
    request += "&api=" + API_VERSION;
    
    // Send request and receive response
    sendMessage(request); 
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE, PROTOCOL_INIT_TIMEOUT); 
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if initialization was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {
        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Initialization failed - bad or missing status";
        
        return response;
    } 

    response.status = ResponseStatusEnum::OK;
    response.error = "";
    initialized = true; 
    return response;
}

ResponseStatus Protocol::update(const std::string& uid) {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;

    if (!initialized) {
        response.error = "Protocol not initialized";
        return response;
    }
    
    if (uid.empty()) {
        response.error = "UID cannot be empty";
        return response;
    }

    // Build update request
    std::string request = "?type=UPDATE";
    request += "&id=" + uid;
    
    // Send request and receive response
    sendMessage(request);
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE); // Use defined verbosity for receive
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if UID from response matches request
    if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
        response.status = ResponseStatusEnum::ERROR;
        response.error = "Response UID mismatch - expected: " + uid + ", received: " + 
                                (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none");
        return response;
    }
    
    // Check if connection was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {

        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Connection failed - bad or missing status";
        return response;
    }

    response.params = responseParams; // Store all response parameters
    response.status = ResponseStatusEnum::OK;
    response.error = "";
    return response;
}

ResponseStatus Protocol::config(const std::string& uid, const std::unordered_map<std::string, std::string>& config) {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;

    if (!initialized) {
        response.error = "Protocol not initialized";
        return response;
    }
    
    if (uid.empty()) {
        response.error = "UID cannot be empty";
        return response;
    }

    // Build configuration request
    std::string request = "?type=CONFIG";
    request += "&id=" + uid;
    
    // Add configuration parameters
    for (const auto& configParam : config) {
        request += "&" + configParam.first + "=" + configParam.second;
    }
    
    // Send request and receive response
    sendMessage(request);
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE); // Use defined verbosity for receive
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
     // Check if UID from response matches request
    if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
        response.status = ResponseStatusEnum::ERROR;
        response.error = "Response UID mismatch - expected: " + uid + ", received: " + 
                                (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none");
        return response;
    }
    
    // Check if connection was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {

        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Connection failed - bad or missing status";
        return response;
    }

    response.status = ResponseStatusEnum::OK;
    response.error = "";
    return response;
}

ResponseStatus Protocol::reset(const std::string& uid) {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;

    if (!initialized) {
        response.error = "Protocol not initialized";
        return response;
    }
    
    if (uid.empty()) {
        response.error = "UID cannot be empty";
        return response;
    }

    // Build reset request
    std::string request = "?type=RESET";
    request += "&id=" + uid;
    
    // Send request and receive response
    sendMessage(request);
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE); // Use defined verbosity for receive
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if UID from response matches request
    if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
        response.status = ResponseStatusEnum::ERROR;
        response.error = "Response UID mismatch - expected: " + uid + ", received: " + 
                                (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none");
        return response;
    }
    
    // Check if connection was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {

        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Connection failed - bad or missing status";
        return response;
    }

    response.status = ResponseStatusEnum::OK;
    response.error = "";
    return response;
}

ResponseStatus Protocol::connect(const std::string& uid, const std::string& pins) {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;

    if (!initialized) {
        response.error = "Protocol not initialized";
        return response;
    }
    
    if (uid.empty()) {
        response.error = "UID cannot be empty";
        return response;
    }

    // Build connect request
    std::string request = "?type=CONNECT";
    request += "&id=" + uid;
    request += "&pins=" + pins;
    
    // Send request and receive response
    sendMessage(request);
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE); // Use defined verbosity for receive
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if UID from response matches request
    if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
        response.status = ResponseStatusEnum::ERROR;
        response.error = "Response UID mismatch - expected: " + uid + ", received: " + 
                                (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none");
        return response;
    }
    
    // Check if connection was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {

        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Connection failed - bad or missing status";
        return response;
    }

    response.status = ResponseStatusEnum::OK;
    response.error = "";
    return response;
}

ResponseStatus Protocol::disconnect(const std::string& uid) {
    ResponseStatus response;
    response.status = ResponseStatusEnum::ERROR;

    if (!initialized) {
        response.error = "Protocol not initialized";
        return response;
    }
    
    if (uid.empty()) {
        response.error = "UID cannot be empty";
        return response;
    }

    // Build disconnect request
    std::string request = "?type=DISCONNECT";
    request += "&id=" + uid;
    
    // Send request and receive response
    sendMessage(request);
    std::string responseMsg = receiveMessage(PROTOCOL_VERBOSE); // Use defined verbosity for receive
    
    // Parse response
    auto responseParams = parseMessage(responseMsg);
    
    // Check if UID from response matches request
    if (responseParams.find("id") == responseParams.end() || responseParams["id"] != uid) {
        response.status = ResponseStatusEnum::ERROR;
        response.error = "Response UID mismatch - expected: " + uid + ", received: " + 
                                (responseParams.find("id") != responseParams.end() ? responseParams["id"] : "none");
        return response;
    }
    
    // Check if connection was successful
    if (responseParams.find("status") == responseParams.end() || responseParams["status"] != "1") {

        response.status = ResponseStatusEnum::ERROR;
        response.error = responseParams.find("error") != responseParams.end() 
                            ? responseParams["error"] : "Connection failed - bad or missing status";
        return response;
    }

    response.status = ResponseStatusEnum::OK;
    response.error = "";
    return response;
}

bool Protocol::isInitialized() {
    return initialized;
}

std::string Protocol::getApiVersion() {
    return API_VERSION;
}